#!/usr/bin/python2 -u

# The MIT License (MIT)
# Copyright (c) 2014 Janez Troha <dz0ny@ubuntu.si>
# Copyright (c) 2014 Bashton Ltd.

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


import hashlib
import re
import logging
import sys
import textwrap

import requests

logger = logging.getLogger('github')

if 'unit2' not in str(sys.argv):
    log_file_handler = logging.FileHandler('/var/log/apt-github.log')
    formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
    log_file_handler.setFormatter(formatter)
    logger.addHandler(log_file_handler)
    logger.setLevel(logging.DEBUG)


class APTMessage(object):
    MESSAGE_CODES = {
        100: 'Capabilities',
        102: 'Status',
        200: 'URI Start',
        201: 'URI Done',
        400: 'URI Failure',
        600: 'URI Acquire',
        601: 'Configuration',
    }

    def __init__(self, code, headers):
        self.code = code
        self.headers = headers

    def encode(self):
        result = '{0} {1}\n'.format(self.code, self.MESSAGE_CODES[self.code])
        for item in self.headers.keys():
            if self.headers[item] is not None:
                result += '{0}: {1}\n'.format(item, self.headers[item])
        return result + '\n'


def parse_package(package, version):
    name = package.get('name')

    re_info = re.compile(
        ur'_(?P<name>\S+)_(?P<version>\S+)_(?P<arch>\S+)\.deb$')  # noqa
    package_info = re.search(re_info, name)

    if package_info:
        arch = package_info.group('arch')
        name = package_info.group('name')
        version = package_info.group('version')
    else:
        arch = 'any'
    user = requests.get(package['uploader']['url']).json()
    return {
        'version': version,
        'arch': arch,
        'name': name,
        'maintainer': '{} <{}>'.format(user['name'], user['email']),
        'size': package.get('size'),
        'download': package.get('browser_download_url'),
        'updated_at': package.get('updated_at'),
    }


def generate_package_info(package):

    return textwrap.dedent('''\
    Package: {name}
    Version: {version}
    Architecture: {arch}
    Maintainer: {maintainer}
    Size: {size}
    Filename: {download}

    ''').format(**package)


def generate_release_info(release):

    return textwrap.dedent('''\
    Origin: . {distribution}
    Label: . {distribution}
    Codename: {distribution}
    Date: {updated_at}
    Architectures: {archs}
    Components: {component}
    Description: Generated by GitHub

    ''').format(**release)


class GithubPackages(object):
    __eof = False

    def __init__(self):
        self.send_capabilities()
        self.session = requests.Session()

    def packages(self, repo):
        url = 'https://api.github.com/repos/{}/releases'.format(repo)
        req = self.session.get(url, headers={'Accept-Encoding': 'plain'})
        for release in req.json():
            for package in release.get('assets'):
                if package.get('name').endswith('.deb'):
                    yield parse_package(
                        package,
                        release.get('tag_name')
                    )

    def fail(self, uri, message='Failed'):
        self.send_uri_failure({'URI': uri, 'Message': message})

    def _read_message(self):
        """
        Apt uses for communication with its methods the text protocol similar
        to http. This function parses the protocol messages from stdin.
        """
        if self.__eof:
            return None
        result = {}
        line = sys.stdin.readline()
        while line == '\n':
            line = sys.stdin.readline()
        if not line:
            self.__eof = True
            return None
        s = line.split(" ", 1)
        result['_number'] = int(s[0])
        result['_text'] = s[1].strip()

        while not self.__eof:
            line = sys.stdin.readline()
            if not line:
                self.__eof = True
                return result
            if line == '\n':
                return result
            s = line.split(":", 1)
            result[s[0]] = s[1].strip()

    def send(self, code, headers):
        message = APTMessage(code, headers)
        sys.stdout.write(message.encode())

    def send_capabilities(self):
        self.send(100, {'Version': '1.0', 'Single-Instance': 'true'})

    def send_status(self, headers):
        self.send(102, headers)

    def send_uri_start(self, headers):
        self.send(200, headers)

    def send_uri_done(self, headers):
        self.send(201, headers)

    def send_uri_failure(self, headers):
        self.send(400, headers)

    def run(self):
        """Loop through requests on stdin"""
        while True:
            message = self._read_message()
            logger.debug(message)
            if message is None:
                return 0
            if message['_number'] == 600:
                try:
                    if message['URI'].endswith('Release'):
                        self.fetch_release(message)
                    if message['URI'].endswith('binary-amd64/Packages'):
                        self.fetch_packages('amd64', message)
                    if message['URI'].endswith('binary-i386/Packages'):
                        self.fetch_packages('i386', message)
                    else:
                        self.fetch(message)
                except Exception, e:
                    self.fail(message['URI'],
                              e.__class__.__name__ + ": " + str(e))
            else:
                return 100

    def fetch_release(self, msg):
        logger.debug('fetch_release')
        updated_at = None
        all_arch = []
        for package in self.packages('dz0ny/apt-transport-github'):
            if package['arch'] not in all_arch:
                all_arch.append(package['arch'])
            if not updated_at:
                updated_at = package.get('updated_at')

        uri = msg['URI']
        filename = msg['Filename']
        rel = {
            'archs': ' '.join(all_arch),
            'updated_at': updated_at,
            'distribution': 'any',
            'component': 'latest',
        }
        self.save(uri, filename, updated_at, generate_release_info(rel))

    def fetch_packages(self, arch, msg):
        logger.debug('fetch_packages')
        packages = []
        updated_at = None
        for package in self.packages('dz0ny/apt-transport-github'):
            if package['arch'] == arch:
                if not updated_at:
                    updated_at = package.get('updated_at')
                packages.append(generate_package_info(package))

        uri = msg['URI']
        filename = msg['Filename']
        self.save(uri, filename, updated_at, ''.join(packages))

    def fetch(self, msg):
        uri = msg['URI']
        filename = msg['Filename']

        response = self.session.get(uri, stream=True)
        self.send_status({'URI': uri, 'Message': 'Waiting for headers'})

        if response.status_code != 200:
            self.send_uri_failure({
                'URI': uri,
                'Message': str(response.status_code + '  ' + response.text),
                'FailReason': 'HttpError' + str(response.status_code)})
            response.close()
            return

        self.send_uri_start({
            'URI': uri,
            'Size': response.headers['content-length'],
            'Last-Modified': response.headers['last-modified']})

        f = open(filename, "w")
        hash_sha256 = hashlib.sha256()
        hash_md5 = hashlib.md5()
        for chunk in response.iter_content(4096):
            if not len(chunk):
                break
            hash_sha256.update(chunk)
            hash_md5.update(chunk)
            f.write(chunk)
        response.close()
        f.close()

        self.send_uri_done({
            'URI': uri,
            'Filename': filename,
            'Size': response.headers['content-length'],
            'Last-Modified': response.headers['last-modified'],
            'MD5-Hash': hash_md5.hexdigest(),
            'MD5Sum-Hash': hash_md5.hexdigest(),
            'SHA256-Hash': hash_sha256.hexdigest()})

    def save(self, uri, filename, last_modified, data):
        self.send_uri_start({
            'URI': uri,
            'Size': len(data),
            'Last-Modified': last_modified})

        f = open(filename, "w")
        hash_sha256 = hashlib.sha256()
        hash_md5 = hashlib.md5()
        hash_sha256.update(data)
        hash_md5.update(data)
        f.write(data)
        f.close()

        self.send_uri_done({
            'URI': uri,
            'Filename': filename,
            'Size': len(data),
            'Last-Modified': last_modified,
            'MD5-Hash': hash_md5.hexdigest(),
            'MD5Sum-Hash': hash_md5.hexdigest(),
            'SHA256-Hash': hash_sha256.hexdigest()})


if __name__ == '__main__':
    try:
        method = GithubPackages()
        ret = method.run()
        sys.exit(ret)
    except KeyboardInterrupt:
        pass
